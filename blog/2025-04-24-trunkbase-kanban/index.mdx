---
slug: trunkbase-kanban
title: Trunk base ++ et kanban
authors: [adelegue]
tags: [devflow]
---

# Trunk base et kanban

√Ä la MAIF, le flow de d√©v le plus commun√©ment appliqu√©, c'est du gitflow et du scrum.
Personnellement, j'ai du mal √† comprendre le gitflow et je ne comprends pas √† quoi sert la branche develop du moins pour le d√©veloppement d'application. Les branches support ne sont pas utiles car, on ne maintient qu'une version de notre application √† un moment donn√©.
J'ai √©galement l'impression que la branche master et develop finissent obligatoirement par avoir un historique divergent, √† moins de rebase develop √† partir de master de faire un force push.

En ce qui concerne le scrum, je trouve que √ßa g√©n√®re une pression continue, on est toujours en train de se prendre la t√™te sur les stories pour savoir si √ßa va rentrer ou non dans le sprint. √áa n'est pas tr√®s chill comme m√©thode.

Depuis quelques ann√©es sur notre projet, nous avons mis en place un flow un peu atypique √† base de trunk base. C'est ce que je vais vous pr√©senter ici.

{/* truncate */}

## L'instant musical

<iframe width="560" height="315" src="https://www.youtube.com/embed/ktHLBveEOdg?si=6mS7W41Nuip6FJSE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Le commencement

Au d√©but du projet, c'√©tait simple, peu d'utilisateurs, 2 d√©v sur le projet, on faisait un trunk base classique et on livrait en production tr√®s rapidement.

Mais le projet grossit, la complexit√© aussi, l'√©quipe aussi, le nombre de features d√©velopp√©es en parall√®le √©galement et les ennuis commenc√®rent.


Le contexte du projet, c'est une API qui g√®re des donn√©es de personnes. Ces donn√©es √©taient, initialement stock√©es dans un progiciel, et nous cherchons maintenant √† rapatrier ces donn√©es au fur et √† mesure dans notre API.
Pour √ßa nous avons 2 briques bas√©es sur kafka qui vont synchroniser en presque temps r√©√©l du progiciel vers notre API ou de notre API vers le progiciel.

```mermaid
flowchart LR
   Topic1@{ shape: das, label: "Topic kafka evt Progiciel" }
   Topic2@{ shape: das, label: "Topic kafka evt API" }

   progiciel["Progiciel üò±"]
   API["API"]
   Bridge1["Bridge"]
   Bridge2["Bridge"]

   progiciel e1@--> Topic1
   e1@{ animate: true }
   Topic1 e2@--> Bridge1
   e2@{ animate: true }
   Bridge1 e3@--> API
   e3@{ animate: true }
   API e4@--> Topic2
   e4@{ animate: true }
   Topic2 e5@--> Bridge2
   e5@{ animate: true }
   Bridge2 e6@--> progiciel
   e6@{ animate: true }
```


Il est tr√®s difficile de tester correctement, lors de la phase de d√©v, les briques de synchronisation, car le progiciel (et ses API) sont pleins de surprises.

Il arrive donc r√©guli√®rement qu'une PR qui a √©t√© review par l'√©quipe et, qui est couverte par des tests unitaires, ne fonctionne pas du tout une fois d√©ploy√©e sur un environnement de QA.

Avec quatre d√©veloppeurs dans l'√©quipe, et avec du trunk base, on arrive vite √† une situation ou une PR merg√©e bloque tout le monde, car elle contient un bug.

Ici, tant que le bug de feature 1 n'est pas corrig√©, il n'est pas possible de livrer feature 2 et feature 3 en production :

```mermaid
gitGraph:
    commit "init"
    branch feature1
    checkout feature1
    commit tag:"C'est KO !"
    checkout main
    merge feature1
    branch feature2
    checkout feature2
    commit id:"Feature 2"
    checkout main
    merge feature2
    branch feature3
    checkout feature3
    commit id:"Feature 3"
    checkout main
    merge feature3
    commit
```

## La liste au p√®re no√´l

Ce que l'on souhaite, c'est :
* Pouvoir lotir des features dans une release candidate
* √âviter d'embarquer une feature qui bloque les autres features
* Avoir un bon niveau de confiance lors de notre mise en prod et √©viter les bugs (√©videmment)
* Avoir un changelog et connaitre le contenu de chaque release
* Donner de la visibilit√© √† nos clients sur les features en cours de d√©v et le contenu des releases √† venir

## The new flow

Sur un d√©veloppement de librairie, il peut y avoir plusieurs versions en parall√®le √† g√©rer. Dans un contexte d'API √ßa n'est pas le cas.
Le trunk base, o√π, le tronc est la version de prod, nous convient parfaitement.

Par contre, on souhaite identifier les features qui partiront ensemble dans la prochaine release. Apr√®s des d√©bats endiabl√©s, on a donc d√©cid√© de suivre le flow suivant :

!["Arguing"](./meme.jpg)

* On cr√©e une branche `release/X.X.X` √† partir du tronc qui servira de receptacle pour les features de cette version
* On cr√©e dans github une milestone `X.X.X` qui nous servira de changelog
* Le d√©veloppeur prend une t√¢che prioritaire dans Jira
* Pour chaque t√¢che, on cr√©e une branche `feature/foo` √† partir de `release/X.X.X`
* On cr√©e une PR pour la branche `feature/foo`, on l'ajoute √† la milestone `X.X.X` et on choisit `release/X.X.X` comme cible pour le merge
* On fait appara√Ætre le num√©ro de la jira correspondante dans le titre de la PR
* La CI (ici github action) en plus de l'ex√©cution des tests etc, produit un livrable avec la `X.X.X-num√©roPR-SNAPSHOT`, ce livrable sera testable sur un env de QA
* Une fois la PR valid√©e par les tests, revue etc on la merge sur la branche `release/X.X.X` (avec un petit rebase avant), une github action publie un message dans teams pour indiquer le contenu de la release a chang√© et la liste des features merg√©es est affich√©e.
* Avant de cr√©er une release, on refait une passe de tests pour v√©rifier toutes les features ensembles
* Pour faire une release, on "rebase and merge" `release/X.X.X` sur le tronc, on utilise le gradle release plugin pour tagger la version et passer √† la version suivante. Le livrable final est produit ici.
* On rebase ensuite toutes les autres branches de release qui seraient en cours.

On obtient quelque chose comme √ßa :

```mermaid
gitGraph:
    commit "init"
    branch release/2.1.0
    checkout release/2.1.0
    branch feature/jira-1
    checkout feature/jira-1
    commit id:"Feature 1"
    checkout release/2.1.0
    merge feature/jira-1
    branch feature/jira-2
    checkout feature/jira-2
    commit id:"Feature 2"
    checkout release/2.1.0
    merge feature/jira-2
    checkout main
    merge release/2.1.0
    commit tag:"v2.1.0"
    commit id: "Version 2.2.0-SNAPSHOT"
    branch release/2.2.0
    checkout release/2.2.0
    branch feature/jira-3
    checkout feature/jira-3
    commit id:"Feature 3"
    checkout release/2.2.0
    merge feature/jira-3
    branch feature/jira-4
    checkout feature/jira-4
    commit id:"Feature 4"
    checkout release/2.2.0
    merge feature/jira-4
    checkout main
    merge release/2.2.0
    commit tag:"v2.2.0"
    commit id: "Version 2.3.0-SNAPSHOT"
    commit
```

### Le feature flipping

Tout √ßa ne serait pas possible sans feature flipping. √áa nous permet de livrer en production sans attendre d'avoir d√©velopp√© l'int√©gralit√© d'une feature.

On alterne entre PR dormante, qu'on garde au chaud pour plus tard, et feature flipping sur lequel on teste, au minimum, la d√©sactivation pour s'assurer que √ßa puisse monter en prod.

### Organisation de l'√©quipe

Tous les lundis, on fait le point sur les features qui ont √©t√© d√©velopp√©es et test√©es et qui sont pr√™tes √† partir. Si on a rien, bah on verra plus tard hein !
Si on a des choses √† livrer, le mardi, on fait le dernier tour de tests et on pr√©pare la release finale.

Le mercredi on livre en prod et c'est reparti pour un tour.

Comme indiqu√© plus t√¥t, les tests automatis√©s pr√©sents dans nos livrables ne suffisent pas car, on ne maitrise pas le format des donn√©es qui proviennent du progiciel.
Notre testeur √† √©galement une batterie de test automatis√©s qui s'appuient sur un environnement de QA, √ßa fait un bon filet de s√©curit√© en plus.

Si on r√©sume, on pratique un mix de kanban et de scrum avec une it√©ration d'une semaine et un trunk base qui est un mix de trunk base et de gitflow.

### Gestion des hotfix

Pour g√©rer un hotfix, on peut tout simplement tirer une branche √† partir du tronc, on suivra ensuite le flow classique.

## Et maintenant ?

Apr√®s discussion avec l'√©quipe, on a identifi√© quelques petites pierres dans l'engrenage :
* on g√©n√®re beaucoup d'aller-retour entre le testeur et les d√©v pour d√©ployer la bonne version √† tester
* si on monte en prod une version v√©rol√©e, le tronc devient KO et √ßa peut poser des probl√®mes pour la suite et emp√™cher de futures mises en prod.

Pour limiter les aller-retour entre les d√©v et les tests, l'id√©e serait de rendre autonome le testeur sur le d√©ploiement des versions.

Pour ne pas pourrir le tronc avec une version livr√©e √† tort en production, on pourrait merger la branche de release qu'une fois la mise en prod faite et valid√©e.

That all folks, To be continued !

## PS

Si vous avez des remarques, des commentaires, des critiques ...  [c'est ici que √ßa se passe](https://github.com/larousso/larousso.github.com/discussions/5)