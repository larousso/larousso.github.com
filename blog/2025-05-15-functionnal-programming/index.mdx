---
slug: functional-programming-intro
title: La programmation fonctionnelle en java
authors: [adelegue]
tags: [patterns, java, prog-fonctionnelle]
---

import img from './img/img.png'
import lego from './img/lego-516559_640.jpg';

# La programmation fonctionnelle en java

La version 8 du jdk a amen√© la programmation fonctionnelle en java, notamment, avec les fameuses lambda et les streams pour les collections.

Mais peut-on r√©ellement faire de la prog fonctionnelle en java ?
Dans ce post, on fera un tour de quelques notions de prog fonctionnelle et on verra ce qu'on peut faire en java.

{/* truncate */}

## L'instant musical

<iframe width="560" height="315" src="https://www.youtube.com/embed/zYwCmcB0XMw?si=10p-SuRij0U20Mdq" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Fonctions pures, fonctions totales et transparence r√©f√©rentielle

En programmation fonctionnelle, on parle de manipulation de fonctions (pas con, en m√™me temps, c'est dans le nom !). Les fonctions peuvent avoir plusieurs propri√©t√©s, elles peuvent √™tre
* Pures
* Totales
* R√©f√©rentiellement transparentes

### Fonctions pures

Pour qu'une fonction soit pure :
* Sa valeur de retour doit toujours √™tre la m√™me pour les m√™mes arguments en entr√©e
* Elle ne doit pas avoir d'effet de bord : pas d'effet sur des variables en dehors du scope de la fonction.

Par exemple, cette fonction est pure :
```java
int additionner(int a, int b) {
    return a + b;
}
```

Si on ex√©cute plusieurs fois `additionner(2, 3)` on obtiendra toujours `5`.
Aucune manipulation de variable externe, donc pas d'effet de bord.

### Transparence r√©f√©rentielle

La transparence r√©f√©rentielle, c'est lorsque substituer une fonction par une variable et manipuler cette variable revient √† manipuler directement la fonction.
Les fonctions pures sont r√©f√©rentiellement transparente.

Comme √ßa, √ßa peut para√Ætre un peu flou, mais on va prendre un exemple.

On va commencer par d√©finir un tuple :
```java
record Tuple<A, B>(A a, B a) {
    static <A, B> Tuple<A, B> of(A a, B b) {
        return new Tuple<>(a, b);
    }
}
```

Maintenant, on va regarder si `addtionner` respecte la transparence r√©f√©rentielle. Pour √ßa t1 et t2 doivent √™tre √©quivalent :

```java
var result = additionner(2, 3);
var t1 = Tuple.of(result, result);
var t2 = Tuple.of(additionner(2, 3), additionner(2, 3));
```
Ici, c'est le cas, `addtionner` est **r√©f√©rentiellement transparente**.

Maintenant imaginons la fonction suivante :

```java
static <T> T getValue(Iterator<T> iterator) {
    if (iterator.hasNext()) {
        return iterator.next();
    } else {
        return null;
    }
}
```

On va regarder si cette fonction est r√©f√©rentiellement transparente :

```java
var iterator = List.of(1, 2, 3, 4, 5, 6).iterator();
var result = getValue(iterator);

var t1 = Tuple.of(result, result);
var t2 = Tuple.of(getValue(iterator), getValue(iterator));
```

Ici la fonction est **r√©f√©rentiellement opaque**. √Ä chaque √©x√©cution, on fait avancer l'`iterator` et on obtiendra des r√©sultats et des comportements diff√©rents.

### Fonction totales

On va appeler fonction totale, une fonction qui retournera un r√©sultat pour l'ensemble des valeurs possibles en entr√©e.

La fonction `additionner`, est une fonction totale :
```java
int additionner(int a, int b) {
    return a + b;
}
```
Elle retournera un r√©sultat pour la totalit√© des entiers.


La fonction `diviser`, d√©finie ainsi n'est pas totale :

```java
int diviser(int value, int par) {
    return value / par;
}
```

En effet, la division par `0` n'est pas possible. Pour rendre cette fonction totale, il faudra l'√©crire :

```java
int diviser(int value, NonZeroInt par) {
    return value / par;
}
```

Avec par exemple :
```java
record NonZeroInt(int value) {
    public NonZeroInt {
        if (value == 0) throw new IllegalArgumentException("0 n'est pas authoris√©");
    }
}
```


## Composition de fonction

Un truc cool avec les fonctions, c'est qu'elles peuvent √™tre compos√©e. √Ä partir de petites pi√®ces, on peut fabriquer des pi√®ces plus grosses et ainsi de suite.

<img src={lego} width={400}></img>

La bonne nouvelle, c'est qu'en java, c'est possible ! L'interface fonctionnelle `java.util.Function` (ainsi que `java.util.BiFunction`) a une m√©thode `andThen` qui permet de faire de la composition.

Imaginons les fonctions suivantes :
* `fabriquerBrique` : `üåç -> üß±`
* `fabriquerMaison` : `üß±-> üè†`

En composant ces 2 fonctions, on est capable de construire une maison :

`fabriquerMaisonDeZ√©ro` : `üåç-> üè†`
>    = `üåç -> üß± puis üß±-> üè†`

>    = `fabriquerBrique` ¬∞ `fabriquerMaison`

<a href="https://typelevel.org/cats/" target="_blank"><img src="https://typelevel.org/cats/img/cats2.png" /></a>

En code java, on aura :

```java
Function<Argile, Brique> fabriquerBrique = ???;
Function<Brique, Maison> fabriquerMaison = ???;

Function<Argile, Maison> fabriquerMaisonDeZero = fabriquerBrique.andThen(fabriquerMaison);
```

## Fonctions d'ordre sup√©rieur

Une fonction d'ordre sup√©rieur est
* soit une fonction qui prend en param√®tre une fonction
* soit une fonction qui retourne une fonction

C'est devenu, tr√®s courant en java. On pense par exemple √† l'API de stream avec les fonctions `map`, `flatMap`, `filter` etc.

## Curryfication et application partielle

En java, quand une fonction ou une m√©thode a plusieurs arguments, on l'√©crit g√©n√©ralement comme √ßa

```java
int additionner(int a, int b) {
    return a + b;
}
```

Alors qu'en haskell, on √©crira plut√¥t quelque chose comme √ßa :
```haskell
additionner:: Int -> Int -> Int
additionner = a  -> b -> a + b
```

Ce qui revient √† √©crire √ßa en java :
```java
Function<Integer, Function<Integer, Integer>> additionner = a -> b -> a + b;

// Si on veut s'en servir :
Integer deuxPlusTrois = additionner.apply(2).apply(3);
```

On vient de transformer une fonction qui prend un tuple d'entier et qui retourne un entier en une fonction, qui retourne une fonction, qui retourne un entier.

On appel √ßa la curryfication.

<img src={"https://upload.wikimedia.org/wikipedia/commons/2/27/Stephen_Curry_Shooting_%28cropped%29.jpg"} width={300}/>

Un des avantages de la curryfication, c'est de pouvoir faire de l'application partielle.
Par exemple, on peut cr√©er une fonction `plus2` en faisant :

```java
Function<Integer, Function<Integer, Integer>> additionner = a -> b -> a + b;
// Application partielle :
Function<Int, Int> plusDeux = additionner.apply(2);

// On peut utiliser notre fonction plusDeux :
Integer deuxPlusTrois = plusDeux.apply(3);
```

L'application partielle, c'est un peu ce que font nos classes en java. Le constructeur va capter un contexte qui pourra √™tre utilis√© plus tard avec les m√©thodes de classe.

En r√®gle g√©n√©rale, java n'est pas tr√®s adapt√© pour la curryfication, la syntaxe est un peu trop lourde.

On aimerait pouvoir √©crire :
```java
Integer deuxPlusTrois = additionner(2)(3);
```
√Ä la place de :
```java
Integer deuxPlusTrois = additionner.apply(2).apply(3);
```

D'ailleurs, dans scala, c'est juste du sucre syntaxique. Pour les m√©thodes qui s'appellent `apply`, on peut remplacer `foo.apply(bar)` par `foo(bar)`. √áa all√®ge grandement le code.

Autre point n√©gatif en java, on aimerait pouvoir remplacer
```java
Function<Integer, Function<Integer, Integer>> additionner = a -> b -> a + b;
```

Par

```java
Integer -> Integer -> Integer additionner = a -> b -> a + b;
```

Comme c'est le cas en kotlin ou en scala.

Il existe quand m√™me certains use cases ou l'application partielle de fonction est utile : c'est dans les lambdas.

Par exemple, dans un stream, √† la place de :

```java
var context = UnContexteDeLExterieur();

list
    .stream()
    .map(value -> faitQuelqueChose(context, value))
    .toList();
```

On pourra √©crire :

```java
var context = UnContexteDeLExterieur();

list
    .stream()
    .map(faitQuelqueChose(context))
    .toList();
```
avec

```java
static Function<String, Int> faitQuelqueChose(UnContexteDeLExterieur context) {
    return str -> {
      if (context.bar()) {
          return str.length();
      } else {
          return 42;
      }
    };
}
```
Ici, c'est une m√©thode qui retourne une fonction, c'est presque de la curryfication.

## Vavr

Vavr est une librairie java tr√®s utile pour faire du fonctionnel en java. Vavr est un portage d'une partie du SDK du langage scala.

On va y retrouver des `Option`, `Either`, `Try` dont on parlera plus tard, une API de collections immutable, des Tuples etc.

Ce qui va nous int√©resser ici, ce sont les fonctions. Dans le jdk, on va trouver nativement
* `java.util.function.Function` : `a -> b`
* `java.util.function.BiFunction` : `(a, b) -> c`
* `java.util.function.Supplier` : `() -> a`
* `java.util.function.Consumer` : `a -> {}`
* `java.lang.Runnable` : `() -> {}`
* `java.util.function.Predicate` : `a -> true|false`
* `java.util.function.BiPredicate` : `(a, b) -> true|false`

C'est une bonne base, mais on va se trouver limit√© pour un usage plus avanc√©.
Un point important, on ne peut pas lever de "CheckedException" dans les fonctions natives du JDK.

De son c√¥t√© vavr va proposer :
* `Function0` : `() -> a`
* `Function1` : `a -> b`
* `Function2` : `(a, b) -> c`
* ...
* `Function8` : `(a, b, c, d, e, f, g, h) -> j`

Les checkedFunction pour pouvoir lever des exceptions dans une lambda
* `CheckedFunction0` : `() -> a`
* `CheckedFunction1` : `a -> b`
* `CheckedFunction2` : `(a, b) -> c`
* ...
* `CheckedFunction8` : `(a, b, c, d, e, f, g, h) -> j`

Chaque fonction expose une m√©thode de curryfication pour par exemple, passer de `(a, b) -> c` √† `a -> b -> c`.

## Aller plus haut

<img src={img} width={400} />

Ici, on a vu quelques propri√©t√©s que peuvent avoir les fonctions et qui peuvent nous guider pour faire les choses un peu plus proprement.
Mais en l'√©tat, on n'ira pas tr√®s loin pour coder une application compl√®te avec ce qu'on vient de voir.

Pour utiliser des fonctions pures et r√©f√©rentiellement transparentes, il nous faudra des armes suppl√©mentaires comme l'immutabilit√©, la gestion des effets de bords, utiliser le syst√®me de type, etc.

Pour compl√©ter ce post qui sert d'introduction, des posts d√©di√©s pour d√©tailler chaque item seront publi√©s. On pourra ensuite assembler brique par brique nos fonctions et cr√©er un programme complet et robuste.